<?xml version="1.0" encoding="UTF-8"?>
<!--Designed and generated by Altova StyleVision Enterprise Edition 2013 rel. 2 sp2 (x64) - see http://www.altova.com/stylevision for more information.-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:altova="http://www.altova.com" xmlns:altovaext="http://www.altova.com/xslt-extensions" xmlns:clitype="clitype" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:iso4217="http://www.xbrl.org/2003/iso4217" xmlns:ix="http://www.xbrl.org/2008/inlineXBRL" xmlns:java="java" xmlns:link="http://www.xbrl.org/2003/linkbase" xmlns:sps="http://www.altova.com/StyleVision/user-xpath-functions" xmlns:svrl="http://purl.oclc.org/dsdl/svrl" xmlns:xbrldi="http://xbrl.org/2006/xbrldi" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" exclude-result-prefixes="#all" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/xhtml">
	<xsl:output version="1.0" method="xhtml" indent="yes" encoding="UTF-8" use-character-maps="spaces" doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN" doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/>
	<xsl:character-map name="spaces">
		<xsl:output-character character="&#160;" string="&amp;nbsp;"/>
	</xsl:character-map>
	<xsl:param name="altova:bGeneratingFromPxf" select="false()"/>
	<xsl:param name="SV_OutputFormat" select="'HTML'"/>
	<xsl:param name="SV_BaseOutputFileName" as="xs:string?">
		<xsl:sequence select="for $i in altovaext:get-base-output-uri(), $j in tokenize( $i, &apos;[/\\]&apos; )[last()] return replace( $j, &apos;\.[^\.\s#%;]*$&apos;, &apos;&apos; )" use-when="function-available(&apos;altovaext:get-base-output-uri&apos;)"/>
	</xsl:param>
	<xsl:param name="SV_GeneratedFileNamePrefix" select="if ( $SV_BaseOutputFileName ) then $SV_BaseOutputFileName else &apos;QCwithWarnings_altLocation&apos;" as="xs:string?"/>
	<xsl:param name="Title" select="'COBie QC report - Design Deliverable'"/>
	<xsl:variable name="XML" select="/"/>
	<xsl:variable name="altova:nPxPerIn" select="96"/>
	<xsl:variable name="altova:CssImages" select="()"/>
	<xsl:variable name="altova:DesignAfterStep1">
		<altova:main-document url="{if ($SV_BaseOutputFileName) then concat($SV_BaseOutputFileName,'.xhtml') else ''}">
			<html>
				<head>
					<title/>
					<meta http-equiv="X-UA-Compatible" content="IE=7"/>
					<style type="text/css">
						<altova:UnescapedText>
/*&lt;![CDATA[/* */<![CDATA[
body { background:#fff;
font:76%/160% "Trebuchet MS",Verdana,Arial,Helvetica,sans-serif;
 }
 table { border-right:1px solid #e5eff8;
border-top:1px solid #e5eff8;
width:90%;
 }
 tr.odd td { background:#f7fbff;
 }
 tr.odd .column1 { background:#f4f9fe;
 }
 .column1 { background:#f9fcfe;
 }
 td { border-bottom:1px solid #e5eff8;
border-left:1px solid #e5eff8;
color:#678197;
padding:1em 1em;
text-align:center;
 }
 th { border-bottom:1px solid #e5eff8;
border-left:1px solid #e5eff8;
color:#678197;
font-weight:normal;
padding:.3em 1em;
text-align:left;
 }
 thead th { background:#f4f9fe;
color:#66a3d3;
font:bold 1.2em/2em "Century Gothic","Trebuchet MS",Arial,Helvetica,sans-serif;
text-align:center;
 }
 tfoot th { background:#f4f9fe;
text-align:center;
 }
 tfoot th strong { color:#66a3d3;
font:bold 1.2em "Century Gothic","Trebuchet MS",Arial,Helvetica,sans-serif;
margin:.5em .5em .5em 0;
 }
 tfoot th em { color:#f03b58;
font-size:1.1em;
font-style:normal;
font-weight:bold;
 }
 table a, table a:link, table a:visited { border:none;
 }
 a:hover,a:focus { border-bottom:1px solid #f03b58;
color:#f03b58;
text-decoration:none;
 }
 a:visited { border-bottom:none;
color:rgb(0, 138, 255);
text-decoration:none;
 }
 a:link { border-bottom:1px dotted rgb(0, 138, 255);
color:rgb(0, 138, 255);
text-decoration:none;
 }
 html, body, form, fieldset, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, dl, address { margin:10px;
padding:0;
 }
 p { font-size:small;
margin-left:20px;
 }
 h2 { font-size:xx-large;
 }
 h3 { font-size:x-large;
 }
 h4 { font-size:large;
 }
 h5 { font-size:medium;
 }
]]>/*]]&gt;/* */
</altova:UnescapedText>
					</style>
					<xsl:comment>[if IE]&gt;&lt;STYLE type=&quot;text/css&quot;&gt;.altova-rotate-left-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3)} .altova-rotate-right-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1)} &lt;/STYLE&gt;&lt;![endif]</xsl:comment>
					<xsl:comment>[if !IE]&gt;&lt;!</xsl:comment>
					<style type="text/css">.altova-rotate-left-textbox{-webkit-transform: rotate(-90deg) translate(-100%, 0%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(-90deg) translate(-100%, 0%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(-90deg) translate(-100%, 0%); -ms-transform-origin: 0% 0%;}.altova-rotate-right-textbox{-webkit-transform: rotate(90deg) translate(0%, -100%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(90deg) translate(0%, -100%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(90deg) translate(0%, -100%); -ms-transform-origin: 0% 0%;}</style>
					<xsl:comment>&lt;![endif]</xsl:comment>
					<style type="text/css">@page { margin-left:0.60in; margin-right:0.60in; margin-top:0.79in; margin-bottom:0.79in } @media print { br.altova-page-break { page-break-before: always; } }</style>
				</head>
				<body>
					<h1>
						<xsl:for-each select="$Title">
							<xsl:value-of select="."/>
						</xsl:for-each>
					</h1>
					<p>
						<span>
							<xsl:variable name="altova:seqContentStrings_0">
								<xsl:value-of select="format-number(number(substring(string(string(current-dateTime())), 1, 4)), '0000')"/>
								<xsl:variable name="sText" as="xs:string?">
									<xsl:text>-</xsl:text>
								</xsl:variable>
								<xsl:value-of select="$sText"/>
								<xsl:value-of select="format-number(number(substring(string(current-dateTime()), 6, 2)), '00')"/>
								<xsl:variable name="sText" as="xs:string?">
									<xsl:text>-</xsl:text>
								</xsl:variable>
								<xsl:value-of select="$sText"/>
								<xsl:value-of select="format-number(number(substring(string(current-dateTime()), 9, 2)), '00')"/>
								<xsl:variable name="sText" as="xs:string?">
									<xsl:text>T</xsl:text>
								</xsl:variable>
								<xsl:value-of select="$sText"/>
								<xsl:value-of select="format-number(number(substring(string(current-dateTime()), 12, 2)), '00')"/>
								<xsl:variable name="sText" as="xs:string?">
									<xsl:text>:</xsl:text>
								</xsl:variable>
								<xsl:value-of select="$sText"/>
								<xsl:value-of select="format-number(number(substring(string(current-dateTime()), 15, 2)), '00')"/>
								<xsl:variable name="sText" as="xs:string?">
									<xsl:text>:</xsl:text>
								</xsl:variable>
								<xsl:value-of select="$sText"/>
								<xsl:choose>
									<xsl:when test="contains(string(current-dateTime()), 'Z')">
										<xsl:value-of select="format-number(number(substring-after(substring-after(substring-before(string(current-dateTime()), 'Z'), ':'), ':')), '00')"/>
									</xsl:when>
									<xsl:when test="contains(string(current-dateTime()), '+')">
										<xsl:value-of select="format-number(number(substring-after(substring-after(substring-before(string(current-dateTime()), '+'), ':'), ':')), '00')"/>
									</xsl:when>
									<xsl:when test="contains(substring(string(current-dateTime()), 18), '-')">
										<xsl:value-of select="format-number(number(substring-before(substring(string(current-dateTime()), 18), '-')), '00')"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="format-number(number(substring(string(current-dateTime()), 18)), '00')"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="altova:sContent_0" select="string($altova:seqContentStrings_0)"/>
							<xsl:value-of select="$altova:sContent_0"/>
						</span>
					</p>
					<p style="text-align:justify; ">
						<span>
							<xsl:text>Note:&#160; This checking routine only validates the internal quality of the COBie file.&#160; It does not validate the quality of the data with respect to the actual project.&#160; For more information on the COBie checker please visit the COBie Means and Methods page at:</xsl:text>
						</span>
					</p>
					<altova:hyperlink>
						<xsl:choose>
							<xsl:when test="not(string(&apos;http://www.buildingsmartalliance.org/index.php/projects/cobie&apos;))">
								<xsl:attribute name="href">
									<xsl:text>#</xsl:text>
								</xsl:attribute>
							</xsl:when>
							<xsl:when test="substring(string(&apos;http://www.buildingsmartalliance.org/index.php/projects/cobie&apos;), 1, 1) = '#'">
								<xsl:attribute name="href">
									<xsl:value-of select="&apos;http://www.buildingsmartalliance.org/index.php/projects/cobie&apos;"/>
								</xsl:attribute>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="href">
									<xsl:if test="substring(string(&apos;http://www.buildingsmartalliance.org/index.php/projects/cobie&apos;), 2, 1) = ':'">
										<xsl:text>file:///</xsl:text>
									</xsl:if>
									<xsl:value-of select="translate(string(&apos;http://www.buildingsmartalliance.org/index.php/projects/cobie&apos;), '&#x5c;', '/')"/>
								</xsl:attribute>
							</xsl:otherwise>
						</xsl:choose>
						<p>
							<span>
								<xsl:text>http://www.buildingsmartalliance.org/index.php/projects/cobie</xsl:text>
							</span>
						</p>
					</altova:hyperlink>
					<hr/>
					<h2>
						<span style="font-weight:bold; ">
							<xsl:text>Instructions</xsl:text>
						</span>
					</h2>
					<p style="text-align:justify; ">
						<span>
							<xsl:text>Save a new copy of your COBie model (either IFC or Spreadsheet) to a new file name so that you have a backup.&#160; Based on the information in this report update the copied file to correct each issue.&#160; To find the error in the COBie file, match the issue by Worksheet Name, Row Number, and object name to the data in your file.&#160; For example, a problem with the fifth space in the space worksheet, pertaining to the room named &quot;Vestibule&quot; would be listed as Space[5]:Vestibule.&#160; Once each relevant issue is fixed, re-run your file and see the impact of your changes. Note that this report provides a generic test, therefore, some issues may be allowed if the terms and conditions of your contract differ from those assumed in this reporting tool.&#160; Please consult your contract to evaluate the specific requirements for specific COBie deliverables on your projects.</xsl:text>
						</span>
					</p>
					<hr/>
					<br/>
					<div style="text-align:left; ">
						<altova:bookmark>
							<xsl:attribute name="name">
								<xsl:value-of select="&apos;TOC&apos;"/>
							</xsl:attribute>
							<altova:toc altova:name="toc"/>
						</altova:bookmark>
						<hr/>
						<xsl:for-each select="$XML">
							<xsl:apply-templates select="svrl:schematron-output"/>
						</xsl:for-each>
					</div>
				</body>
			</html>
		</altova:main-document>
	</xsl:variable>
	<xsl:template match="altova:toc[ @altova:name = 'toc' ]" mode="altova:generate-toc-xslt-tree">
		<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
		<altova:toc altova:design-id="{generate-id()}">
			<xsl:variable name="altova:current-level-id" select="generate-id( ancestor::altova:level[1] )"/>
			<h1 style="text-align:left; ">
				<span>
					<xsl:text>Table of Contents</xsl:text>
				</span>
			</h1>
			<br/>
			<xsl:for-each select="ancestor::*[self::altova:level | self::altova:main-document][1]">
				<xsl:for-each select="descendant::altova:level[ ancestor::*[self::altova:level | self::altova:main-document][1] is current() ]">
					<xsl:variable name="altova:current-level-id" select="generate-id()"/>
					<h3 style="text-align:left; ">
						<xsl:for-each select="descendant::altova:marker[ @altova:name = 'Level1Section' and ancestor::altova:level[1] is current() ]">
							<xsl:variable name="altova:current-marker-id" select="generate-id()"/>
							<a href="{concat(altova:calc-relative-path($altova:source-document/@url,ancestor::*[self::altova:result-document | self::altova:main-document][1]/@url),'#',generate-id())}">
								<span>
									<xsl:choose>
										<xsl:when test="@altova:entrytext">
											<xsl:value-of select="@altova:entrytext"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:apply-templates mode="altova:extract-text-from-marker">
												<xsl:with-param name="altova:level-design-id" select="$altova:current-level-id"/>
												<xsl:with-param name="altova:marker-design-id" select="$altova:current-marker-id"/>
											</xsl:apply-templates>
										</xsl:otherwise>
									</xsl:choose>
								</span>
							</a>
						</xsl:for-each>
					</h3>
					<xsl:for-each select="descendant::altova:level[ ancestor::altova:level[1] is current() ]">
						<xsl:variable name="altova:current-level-id" select="generate-id()"/>
						<h4 style="text-align:left; ">
							<xsl:for-each select="descendant::altova:marker[ @altova:name = 'Level1Section' and ancestor::altova:level[1] is current() ]">
								<xsl:variable name="altova:current-marker-id" select="generate-id()"/>
								<a href="{concat(altova:calc-relative-path($altova:source-document/@url,ancestor::*[self::altova:result-document | self::altova:main-document][1]/@url),'#',generate-id())}">
									<span>
										<xsl:text>&#160;&#160; </xsl:text>
									</span>
									<span>
										<xsl:choose>
											<xsl:when test="@altova:entrytext">
												<xsl:value-of select="@altova:entrytext"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:apply-templates mode="altova:extract-text-from-marker">
													<xsl:with-param name="altova:level-design-id" select="$altova:current-level-id"/>
													<xsl:with-param name="altova:marker-design-id" select="$altova:current-marker-id"/>
												</xsl:apply-templates>
											</xsl:otherwise>
										</xsl:choose>
									</span>
								</a>
							</xsl:for-each>
						</h4>
						<xsl:for-each select="descendant::altova:level[ ancestor::altova:level[1] is current() ]">
							<xsl:variable name="altova:current-level-id" select="generate-id()"/>
							<h5 style="text-align:left; ">
								<xsl:for-each select="descendant::altova:marker[ @altova:name = 'Level1Section' and ancestor::altova:level[1] is current() ]">
									<xsl:variable name="altova:current-marker-id" select="generate-id()"/>
									<a href="{concat(altova:calc-relative-path($altova:source-document/@url,ancestor::*[self::altova:result-document | self::altova:main-document][1]/@url),'#',generate-id())}">
										<span>
											<xsl:text>&#160;&#160;&#160;&#160;&#160; </xsl:text>
										</span>
										<span>
											<xsl:choose>
												<xsl:when test="@altova:entrytext">
													<xsl:value-of select="@altova:entrytext"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:apply-templates mode="altova:extract-text-from-marker">
														<xsl:with-param name="altova:level-design-id" select="$altova:current-level-id"/>
														<xsl:with-param name="altova:marker-design-id" select="$altova:current-marker-id"/>
													</xsl:apply-templates>
												</xsl:otherwise>
											</xsl:choose>
										</span>
									</a>
								</xsl:for-each>
							</h5>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
		</altova:toc>
	</xsl:template>
	<xsl:template match="svrl:schematron-output">
		<xsl:variable name="errorRules" select="svrl:fired-rule[@role=&apos;WorksheetErrors&apos;]"/>
		<xsl:variable name="failedAssertions" select="svrl:failed-assert[preceding-sibling::svrl:fired-rule/@role=&apos;WorksheetErrors&apos;]"/>
		<xsl:variable name="errorRoleReports" select="svrl:successful-report[preceding-sibling::svrl:fired-rule/@role=&apos;WorksheetErrors&apos;]"/>
		<xsl:variable name="errorRoleContent" select="$errorRoleReports |
$failedAssertions"/>
		<altova:level>
			<altova:marker altova:name="Level1Section">
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
				<h2>
					<span>
						<altova:num-lvl altova:format="1.1.1"/>
					</span>
					<span>
						<xsl:text> QC Summary</xsl:text>
					</span>
				</h2>
			</altova:marker>
			<p>
				<span>
					<xsl:text>Note: Row/Column checks are only listed for worksheets containing at least one row, but row count checks are listed for Contact, Facility, Space, Type, and Component (worksheets that must contain data) regardless of row count. </xsl:text>
				</span>
			</p>
			<altova:level>
				<altova:marker altova:name="Level1Section">
					<span>
						<xsl:text>&#160;</xsl:text>
					</span>
					<h3>
						<span>
							<altova:num-lvl altova:format="1.1.1"/>
						</span>
						<span>
							<xsl:text> COBie Summary Table</xsl:text>
						</span>
					</h3>
				</altova:marker>
				<table border="1">
					<xsl:variable name="altova:CurrContextGrid_1" select="."/>
					<xsl:variable name="altova:ColumnData"/>
					<thead>
						<tr>
							<th>
								<span>
									<xsl:text>Worksheet</xsl:text>
								</span>
							</th>
							<th>
								<span>
									<xsl:text>Has Rows?</xsl:text>
								</span>
							</th>
							<th>
								<span>
									<xsl:text>Row Count</xsl:text>
								</span>
							</th>
							<th>
								<span>
									<xsl:text>Row Warning Count</xsl:text>
								</span>
							</th>
							<th>
								<span>
									<xsl:text>Row Error Count</xsl:text>
								</span>
							</th>
						</tr>
					</thead>
					<tbody>
						<xsl:for-each-group group-by="@id" select="svrl:fired-rule[@role=&apos;WorksheetCount&apos;]">
							<xsl:variable name="worksheetName" as="xs:string" select="if (string-length(substring-after(replace(@id,&apos;COBie.&apos;,&apos;&apos;),&apos;.&apos;))=0)
then replace(@id,&apos;COBie.&apos;,&apos;&apos;)
else
substring-after(replace(@id,&apos;COBie.&apos;,&apos;&apos;),&apos;.&apos;)"/>
							<xsl:variable name="singularizedWorksheetName" as="xs:string" select="if(sps:isPluralSheetName($worksheetName)) then sps:singularizeSheetName($worksheetName) else
$worksheetName"/>
							<xsl:variable name="successfulReport" as="xs:string" select="following-sibling::*:successful-report[1]/*:text/text()[1]"/>
							<xsl:variable name="rowCount" as="xs:double" select="number(normalize-space(replace($successfulReport,$worksheetName,&apos;&apos;)))"/>
							<xsl:variable name="idNode" select="@id"/>
							<xsl:for-each select="current-grouping-key()">
								<xsl:variable name="rootMatch" as="xs:string" select="if  ($rowCount&gt;0) then $errorRules[starts-with(@id,current-grouping-key()) and @id!=current-grouping-key()][1]/@id else &apos;n/a&apos;"/>
								<xsl:variable name="matchingErrorRule" select="$failedAssertions[starts-with(preceding-sibling::svrl:fired-rule[1]/@id,current-grouping-key())]/preceding-sibling::svrl:fired-rule[1]"/>
								<xsl:variable name="matchingErrorRuleID" as="xs:string" select="$matchingErrorRule/@id"/>
								<xsl:variable name="failedAsserts" select="$failedAssertions[starts-with(preceding-sibling::svrl:fired-rule[1]/@id,current-grouping-key())]"/>
								<xsl:variable name="errorCount" as="xs:string" select="if (string($rowCount)!=&apos;NaN&apos; and $rowCount&gt;0) then string(count(distinct-values($failedAsserts[not(sps:isAssertWarning(@id))]/svrl:text/*:location))) else &apos;n/a&apos;"/>
								<xsl:variable name="moreThanOneRow" as="xs:boolean" select="$rowCount=$rowCount and $rowCount&gt;0"/>
								<xsl:variable name="warningCount" as="xs:string" select="if (string($rowCount)!=&apos;NaN&apos; and $rowCount&gt;0) then string(count(distinct-values($failedAsserts[sps:isAssertWarning(@id)]/*:text/*:location))) else &apos;n/a&apos;"/>
								<tr>
									<td>
										<xsl:choose>
											<xsl:when test="$rowCount&gt;0">
												<altova:hyperlink>
													<xsl:choose>
														<xsl:when test="not(string(concat(&apos;#&apos;,string($rootMatch))))">
															<xsl:attribute name="href">
																<xsl:text>#</xsl:text>
															</xsl:attribute>
														</xsl:when>
														<xsl:when test="substring(string(concat(&apos;#&apos;,string($rootMatch))), 1, 1) = '#'">
															<xsl:attribute name="href">
																<xsl:value-of select="concat(&apos;#&apos;,string($rootMatch))"/>
															</xsl:attribute>
														</xsl:when>
														<xsl:otherwise>
															<xsl:attribute name="href">
																<xsl:if test="substring(string(concat(&apos;#&apos;,string($rootMatch))), 2, 1) = ':'">
																	<xsl:text>file:///</xsl:text>
																</xsl:if>
																<xsl:value-of select="translate(string(concat(&apos;#&apos;,string($rootMatch))), '&#x5c;', '/')"/>
															</xsl:attribute>
														</xsl:otherwise>
													</xsl:choose>
													<xsl:for-each select="$singularizedWorksheetName">
														<xsl:value-of select="."/>
													</xsl:for-each>
												</altova:hyperlink>
											</xsl:when>
											<xsl:when test="$rowCount=0 or $rowCount!=$rowCount">
												<xsl:for-each select="$singularizedWorksheetName">
													<xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:when>
										</xsl:choose>
									</td>
									<td>
										<xsl:for-each select="$moreThanOneRow">
											<xsl:value-of select="."/>
										</xsl:for-each>
									</td>
									<td>
										<xsl:choose>
											<xsl:when test="string($rowCount)=&apos;NaN&apos;">
												<span>
													<xsl:text>0</xsl:text>
												</span>
											</xsl:when>
											<xsl:when test="string($rowCount)!=&apos;NaN&apos;">
												<xsl:for-each select="$rowCount">
													<xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:when>
										</xsl:choose>
									</td>
									<td>
										<xsl:for-each select="$warningCount">
											<xsl:value-of select="."/>
										</xsl:for-each>
									</td>
									<td>
										<xsl:for-each select="$errorCount">
											<xsl:value-of select="."/>
										</xsl:for-each>
									</td>
								</tr>
							</xsl:for-each>
						</xsl:for-each-group>
					</tbody>
				</table>
				<br/>
				<br/>
			</altova:level>
			<span>
				<xsl:text>&#160;</xsl:text>
			</span>
			<xsl:for-each-group group-by="preceding-sibling::svrl:fired-rule[1]/@id" select="$errorRoleContent">
				<xsl:variable name="ruleGroupName" as="xs:string" select="string(current-grouping-key())"/>
				<xsl:variable name="countTotalSheetRows" as="xs:integer" select="count(distinct-values(current-group()/*:text/*:location))"/>
				<xsl:variable name="countDistinctRowErrors" as="xs:integer" select="count(distinct-values(current-group()[name(self::element())=&apos;svrl:failed-assert&apos; and not(sps:isAssertWarning(@id))]/*:text/*:location))"/>
				<xsl:variable name="distinctRules" select="distinct-values(current-group()[name(.)=&apos;svrl:successful-report&apos;]/svrl:text/text()[1])"/>
				<xsl:variable name="isWorksheet" as="xs:boolean" select="string-length($ruleGroupName)-string-length(translate($ruleGroupName,&apos;.&apos;,&apos;&apos;))=1"/>
				<xsl:variable name="correctCount" as="xs:integer" select="$countTotalSheetRows - $countDistinctRowErrors"/>
				<xsl:variable name="percentCorrect" select="100*(( $correctCount) div $countTotalSheetRows)"/>
				<altova:level>
					<altova:marker altova:name="Level1Section">
						<span>
							<xsl:text>&#160;</xsl:text>
						</span>
						<altova:bookmark>
							<xsl:attribute name="name">
								<xsl:value-of select="encode-for-uri($ruleGroupName)"/>
							</xsl:attribute>
							<h4>
								<xsl:for-each select="$ruleGroupName">
									<span>
										<altova:num-lvl altova:format="1.1.1"/>
									</span>
									<span>
										<xsl:text>&#160;</xsl:text>
									</span>
									<xsl:value-of select="."/>
									<span>
										<xsl:text>&#160; </xsl:text>
									</span>
									<xsl:choose>
										<xsl:when test="$isWorksheet">
											<span>
												<xsl:text>(row count check)</xsl:text>
											</span>
										</xsl:when>
										<xsl:when test="not($isWorksheet) and $countTotalSheetRows=1">
											<span>
												<xsl:text>(checked </xsl:text>
											</span>
											<xsl:for-each select="$countTotalSheetRows">
												<xsl:value-of select="."/>
											</xsl:for-each>
											<span>
												<xsl:text> row)</xsl:text>
											</span>
										</xsl:when>
										<xsl:when test="not($isWorksheet) and $countTotalSheetRows!=1">
											<span>
												<xsl:text>(checked </xsl:text>
											</span>
											<xsl:for-each select="$countTotalSheetRows">
												<xsl:value-of select="."/>
											</xsl:for-each>
											<span>
												<xsl:text> rows)</xsl:text>
											</span>
										</xsl:when>
									</xsl:choose>
								</xsl:for-each>
							</h4>
						</altova:bookmark>
					</altova:marker>
					<p style="text-align:left; ">
						<span style="font-style:italic; ">
							<xsl:text>Total </xsl:text>
						</span>
						<xsl:for-each select="$ruleGroupName">
							<span style="font-style:italic; ">
								<xsl:text>correct </xsl:text>
							</span>
							<span style="font-style:italic; ">
								<xsl:value-of select="."/>
							</span>
							<span>
								<xsl:text> items</xsl:text>
							</span>
							<span style="font-style:italic; ">
								<xsl:text>&#160;</xsl:text>
							</span>
						</xsl:for-each>
						<span style="font-style:italic; ">
							<xsl:text> = </xsl:text>
						</span>
						<xsl:for-each select="$correctCount">
							<xsl:value-of select="."/>
						</xsl:for-each>
						<span style="font-style:italic; ">
							<xsl:text> of </xsl:text>
						</span>
						<xsl:for-each select="$countTotalSheetRows">
							<span style="font-style:italic; ">
								<xsl:value-of select="."/>
							</span>
						</xsl:for-each>
						<span style="font-style:italic; ">
							<xsl:text> (</xsl:text>
						</span>
						<xsl:for-each select="$percentCorrect">
							<span style="font-style:italic; ">
								<xsl:variable name="altova:seqContentStrings_2">
									<xsl:value-of select="format-number(number(string(.)), '##0.##')"/>
								</xsl:variable>
								<xsl:variable name="altova:sContent_2" select="string($altova:seqContentStrings_2)"/>
								<xsl:value-of select="$altova:sContent_2"/>
							</span>
							<span style="font-style:italic; ">
								<xsl:text>% correct</xsl:text>
							</span>
						</xsl:for-each>
						<span style="font-style:italic; ">
							<xsl:text>)</xsl:text>
						</span>
					</p>
					<h5>
						<span style="text-decoration:underline; ">
							<xsl:text>Checks Performed</xsl:text>
						</span>
					</h5>
					<p style="text-align:left; ">
						<xsl:for-each select="$distinctRules">
							<xsl:variable name="currentValue" as="xs:string" select="current()"/>
							<xsl:choose>
								<xsl:when test="position()=last()">
									<xsl:for-each select="$currentValue">
										<xsl:value-of select="."/>
									</xsl:for-each>
								</xsl:when>
								<xsl:when test="position()&lt;last()">
									<xsl:for-each select="$currentValue">
										<xsl:value-of select="."/>
									</xsl:for-each>
									<span>
										<xsl:text>, </xsl:text>
									</span>
								</xsl:when>
							</xsl:choose>
						</xsl:for-each>
					</p>
					<h5>
						<span style="text-decoration:underline; ">
							<xsl:text>Field Error Counts</xsl:text>
						</span>
					</h5>
					<p style="text-align:left; ">
						<xsl:for-each-group group-by="@flag" select="current-group()">
							<xsl:for-each select="current-grouping-key()">
								<xsl:variable name="incorrectFieldOccurenceCount" as="xs:integer" select="count(distinct-values(current-group()[name(self::element())=&apos;svrl:failed-assert&apos; and not(sps:isAssertWarning(@id))]/svrl:text/*:location))"/>
								<xsl:variable name="incorrectFieldOccurencesMessage" as="xs:string" select="concat(concat(string(current-grouping-key()),string(&apos;: &apos;)),string($incorrectFieldOccurenceCount))"/>
								<xsl:for-each select="$incorrectFieldOccurencesMessage">
									<xsl:value-of select="."/>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:if test="position()&gt;=1 and position()&lt;last()">
								<span>
									<xsl:text>, </xsl:text>
								</span>
							</xsl:if>
						</xsl:for-each-group>
					</p>
					<br/>
					<h5>
						<span style="text-decoration:underline; ">
							<xsl:text>Field Warning Counts</xsl:text>
						</span>
					</h5>
					<p style="text-align:left; ">
						<xsl:for-each-group group-by="@flag" select="current-group()">
							<xsl:for-each select="current-grouping-key()">
								<xsl:variable name="incorrectFieldOccurenceCount" as="xs:integer" select="count(distinct-values(current-group()[name(self::element())=&apos;svrl:failed-assert&apos; and sps:isAssertWarning(@id)]/*:text/location))"/>
								<xsl:variable name="incorrectFieldOccurencesMessage" as="xs:string" select="concat(concat(string(current-grouping-key()),string(&apos;: &apos;)),string($incorrectFieldOccurenceCount))"/>
								<xsl:for-each select="$incorrectFieldOccurencesMessage">
									<xsl:value-of select="."/>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:if test="position()&gt;=1 and position()&lt;last()">
								<span>
									<xsl:text>, </xsl:text>
								</span>
							</xsl:if>
						</xsl:for-each-group>
					</p>
				</altova:level>
				<p style="text-align:left; ">
					<altova:hyperlink>
						<xsl:choose>
							<xsl:when test="not(string(&apos;#TOC&apos;))">
								<xsl:attribute name="href">
									<xsl:text>#</xsl:text>
								</xsl:attribute>
							</xsl:when>
							<xsl:when test="substring(string(&apos;#TOC&apos;), 1, 1) = '#'">
								<xsl:attribute name="href">
									<xsl:value-of select="&apos;#TOC&apos;"/>
								</xsl:attribute>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="href">
									<xsl:if test="substring(string(&apos;#TOC&apos;), 2, 1) = ':'">
										<xsl:text>file:///</xsl:text>
									</xsl:if>
									<xsl:value-of select="translate(string(&apos;#TOC&apos;), '&#x5c;', '/')"/>
								</xsl:attribute>
							</xsl:otherwise>
						</xsl:choose>
						<span style="padding-left:25px; ">
							<xsl:text>Table of Contents</xsl:text>
						</span>
					</altova:hyperlink>
				</p>
				<hr/>
			</xsl:for-each-group>
			<span>
				<xsl:text>&#160;</xsl:text>
			</span>
		</altova:level>
		<span>
			<xsl:text>&#160;</xsl:text>
		</span>
		<altova:level>
			<altova:marker altova:name="Level1Section">
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
				<h2>
					<span>
						<altova:num-lvl altova:format="1.1.1"/>
					</span>
					<span>
						<xsl:text> Detailed Error Report Grouped by Error/Warning Type</xsl:text>
					</span>
				</h2>
			</altova:marker>
			<xsl:if test="count($errorRoleContent[name(.)=&apos;svrl:failed-assert&apos; and not(ends-with(@id,&apos;Warning&apos;))])=0">
				<p>
					<span>
						<xsl:text>No Errors</xsl:text>
					</span>
				</p>
			</xsl:if>
			<xsl:for-each-group group-by="preceding-sibling::svrl:fired-rule[1]/@id" select="$errorRoleContent[name(.)=&apos;svrl:failed-assert&apos;]">
				<xsl:variable name="ruleGroupName" as="xs:string" select="string(current-grouping-key())"/>
				<xsl:variable name="isWorksheet" as="xs:boolean" select="string-length($ruleGroupName)-string-length(translate($ruleGroupName,&apos;.&apos;,&apos;&apos;))=1"/>
				<xsl:variable name="errorCount" as="xs:integer" select="count(distinct-values(current-group()[not(sps:isAssertWarning(@id))]/*:text/*:location))"/>
				<xsl:variable name="warningCount" as="xs:integer" select="count(distinct-values(current-group()[sps:isAssertWarning(@id)]/*:text/*:location))"/>
				<altova:level>
					<altova:marker altova:name="Level1Section">
						<span>
							<xsl:text>&#160;</xsl:text>
						</span>
						<h3>
							<xsl:for-each select="$ruleGroupName">
								<span>
									<altova:num-lvl altova:format="1.1.1"/>
								</span>
								<span>
									<xsl:text>&#160;</xsl:text>
								</span>
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> (</xsl:text>
							</span>
							<xsl:for-each select="$errorCount">
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> invalid </xsl:text>
							</span>
							<xsl:choose>
								<xsl:when test="not($isWorksheet) and $errorCount=1">
									<span>
										<xsl:text>row </xsl:text>
									</span>
								</xsl:when>
								<xsl:when test="not($isWorksheet) and $errorCount!=1">
									<span>
										<xsl:text>rows</xsl:text>
									</span>
								</xsl:when>
								<xsl:when test="$isWorksheet">
									<span>
										<xsl:text> worksheet error(s)</xsl:text>
									</span>
								</xsl:when>
							</xsl:choose>
							<span>
								<xsl:text>, </xsl:text>
							</span>
							<xsl:for-each select="$warningCount">
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> warnings)</xsl:text>
							</span>
						</h3>
					</altova:marker>
					<xsl:for-each-group group-by="@id" select="current-group()">
						<xsl:variable name="formattedLocation" as="xs:string" select="sps:COBieLocationHeading( *:text/*:location )"/>
						<xsl:variable name="cobieRowName" as="xs:string" select="substring-before(svrl:text/text()[1] ,&apos;:&apos; )"/>
						<xsl:variable name="cobieRowNameNoPrefix" as="xs:string" select="substring-after($cobieRowName,&apos;.&apos;)"/>
						<xsl:variable name="locationPrefix" as="xs:string" select="substring-before($formattedLocation,&apos; &apos;)"/>
						<xsl:variable name="locationSuffix" as="xs:string" select="substring-after($formattedLocation,&apos; &apos;)"/>
						<xsl:variable name="tableHeadingText" as="xs:string" select="@id"/>
						<xsl:variable name="lastRuleFired" as="xs:string" select="preceding-sibling::svrl:fired-rule[1]/@id"/>
						<xsl:variable name="groupCount" as="xs:integer" select="count(current-group())"/>
						<xsl:variable name="isThisAWarning" as="xs:boolean" select="sps:isAssertWarning(@id)"/>
						<altova:level>
							<altova:marker altova:name="Level2Section">
								<span>
									<xsl:text>&#160;</xsl:text>
								</span>
								<altova:bookmark>
									<xsl:attribute name="name">
										<xsl:value-of select="encode-for-uri(@id)"/>
									</xsl:attribute>
									<h4>
										<span>
											<altova:num-lvl altova:format="1.1.1"/>
										</span>
										<span>
											<xsl:text>&#160;</xsl:text>
										</span>
										<xsl:choose>
											<xsl:when test="$isThisAWarning=true()">
												<span>
													<xsl:text>Warning:&#160; </xsl:text>
												</span>
											</xsl:when>
											<xsl:when test="not($isThisAWarning)">
												<span>
													<xsl:text>Error:&#160; </xsl:text>
												</span>
											</xsl:when>
										</xsl:choose>
										<xsl:for-each select="$tableHeadingText">
											<xsl:value-of select="."/>
										</xsl:for-each>
										<span>
											<xsl:text> (</xsl:text>
										</span>
										<xsl:for-each select="$groupCount">
											<xsl:value-of select="."/>
										</xsl:for-each>
										<span>
											<xsl:text> occurence</xsl:text>
										</span>
										<xsl:if test="$groupCount!=1">
											<span>
												<xsl:text>s</xsl:text>
											</span>
										</xsl:if>
										<span>
											<xsl:text>)</xsl:text>
										</span>
									</h4>
								</altova:bookmark>
							</altova:marker>
							<p>
								<xsl:choose>
									<xsl:when test="count(current-group())=0">
										<span style="text-decoration:underline; ">
											<xsl:text>No Effected Rows</xsl:text>
										</span>
									</xsl:when>
									<xsl:when test="count(current-group())&gt;0">
										<span style="text-decoration:underline; ">
											<xsl:text>Effected Rows:&#160; </xsl:text>
										</span>
									</xsl:when>
								</xsl:choose>
							</p>
							<p style="text-align:left; ">
								<xsl:for-each select="current-group()">
									<xsl:variable name="RowNumber" as="xs:double" select="number(substring-after(sps:COBieLocationHeading(current()/*:text/*:location),&apos; &apos;))+1"/>
									<altova:hyperlink>
										<xsl:choose>
											<xsl:when test="not(string(concat(&apos;#&apos;,*:text/*:location)))">
												<xsl:attribute name="href">
													<xsl:text>#</xsl:text>
												</xsl:attribute>
											</xsl:when>
											<xsl:when test="substring(string(concat(&apos;#&apos;,*:text/*:location)), 1, 1) = '#'">
												<xsl:attribute name="href">
													<xsl:value-of select="concat(&apos;#&apos;,*:text/*:location)"/>
												</xsl:attribute>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="href">
													<xsl:if test="substring(string(concat(&apos;#&apos;,*:text/*:location)), 2, 1) = ':'">
														<xsl:text>file:///</xsl:text>
													</xsl:if>
													<xsl:value-of select="translate(string(concat(&apos;#&apos;,*:text/*:location)), '&#x5c;', '/')"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:for-each select="$RowNumber">
											<xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:if test="position()&gt;=1 and position()&lt;last()">
											<span>
												<xsl:text>, </xsl:text>
											</span>
										</xsl:if>
									</altova:hyperlink>
									<xsl:if test="position() mod 20 =0">
										<p style="text-align:left; "/>
									</xsl:if>
								</xsl:for-each>
							</p>
						</altova:level>
						<p style="text-align:left; ">
							<altova:hyperlink>
								<xsl:choose>
									<xsl:when test="not(string(&apos;#TOC&apos;))">
										<xsl:attribute name="href">
											<xsl:text>#</xsl:text>
										</xsl:attribute>
									</xsl:when>
									<xsl:when test="substring(string(&apos;#TOC&apos;), 1, 1) = '#'">
										<xsl:attribute name="href">
											<xsl:value-of select="&apos;#TOC&apos;"/>
										</xsl:attribute>
									</xsl:when>
									<xsl:otherwise>
										<xsl:attribute name="href">
											<xsl:if test="substring(string(&apos;#TOC&apos;), 2, 1) = ':'">
												<xsl:text>file:///</xsl:text>
											</xsl:if>
											<xsl:value-of select="translate(string(&apos;#TOC&apos;), '&#x5c;', '/')"/>
										</xsl:attribute>
									</xsl:otherwise>
								</xsl:choose>
								<span style="padding-left:25px; ">
									<xsl:text>Table of Contents</xsl:text>
								</span>
							</altova:hyperlink>
						</p>
						<hr/>
					</xsl:for-each-group>
				</altova:level>
				<span>
					<xsl:text>&#160; </xsl:text>
				</span>
			</xsl:for-each-group>
		</altova:level>
		<span>
			<xsl:text>&#160;</xsl:text>
		</span>
		<altova:level>
			<altova:marker altova:name="Level1Section">
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
				<h2>
					<span>
						<altova:num-lvl altova:format="1.1.1"/>
					</span>
					<span>
						<xsl:text> Detailed Error Report Grouped by Row</xsl:text>
					</span>
				</h2>
			</altova:marker>
			<xsl:if test="count($errorRoleContent[name(.)=&apos;svrl:failed-assert&apos;])=0">
				<p>
					<span>
						<xsl:text>No Errors</xsl:text>
					</span>
				</p>
			</xsl:if>
			<xsl:for-each-group group-by="preceding-sibling::svrl:fired-rule[1]/@id" select="$errorRoleContent[name(.)=&apos;svrl:failed-assert&apos;]">
				<xsl:variable name="ruleGroupName" as="xs:string" select="string(current-grouping-key())"/>
				<xsl:variable name="isWorksheet" as="xs:boolean" select="string-length($ruleGroupName)-string-length(translate($ruleGroupName,&apos;.&apos;,&apos;&apos;))=1"/>
				<xsl:variable name="errorCount" as="xs:integer" select="count(distinct-values(current-group()[not(sps:isAssertWarning(@id))]/*:text/*:location))"/>
				<xsl:variable name="warningCount" as="xs:integer" select="count(distinct-values(current-group()[sps:isAssertWarning(@id)]/*:text/*:location))"/>
				<altova:level>
					<altova:marker altova:name="Level1Section">
						<span>
							<xsl:text>&#160;</xsl:text>
						</span>
						<h3>
							<xsl:for-each select="$ruleGroupName">
								<span>
									<altova:num-lvl altova:format="1.1.1"/>
								</span>
								<span>
									<xsl:text>&#160;</xsl:text>
								</span>
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> (</xsl:text>
							</span>
							<xsl:for-each select="$errorCount">
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> invalid </xsl:text>
							</span>
							<xsl:choose>
								<xsl:when test="not($isWorksheet) and $errorCount=1">
									<span>
										<xsl:text>row </xsl:text>
									</span>
								</xsl:when>
								<xsl:when test="not($isWorksheet) and $errorCount!=1">
									<span>
										<xsl:text>rows</xsl:text>
									</span>
								</xsl:when>
								<xsl:when test="$isWorksheet">
									<span>
										<xsl:text> worksheet error(s)</xsl:text>
									</span>
								</xsl:when>
							</xsl:choose>
							<span>
								<xsl:text>, </xsl:text>
							</span>
							<xsl:for-each select="$warningCount">
								<xsl:value-of select="."/>
							</xsl:for-each>
							<span>
								<xsl:text> warnings)</xsl:text>
							</span>
						</h3>
					</altova:marker>
					<xsl:for-each-group group-by="*:text/*:location" select="current-group()">
						<xsl:variable name="formattedLocation" as="xs:string" select="sps:COBieLocationHeading( *:text/*:location )"/>
						<xsl:variable name="cobieRowName" as="xs:string" select="substring-before(svrl:text/text()[1] ,&apos;:&apos; )"/>
						<xsl:variable name="cobieRowNameNoPrefix" as="xs:string" select="substring-after($cobieRowName,&apos;.&apos;)"/>
						<xsl:variable name="locationPrefix" as="xs:string" select="substring-before($formattedLocation,&apos; &apos;)"/>
						<xsl:variable name="locationSuffix" as="xs:string" select="string(number(substring-after($formattedLocation,&apos; &apos;))+1)"/>
						<xsl:variable name="tableHeadingText" as="xs:string" select="if  (not(sps:isPluralSheetName($locationPrefix)))
then 
if (string-length($cobieRowNameNoPrefix)&gt;0) then
concat(concat(concat(concat(sps:singularizeSheetName($locationPrefix),&apos;[&apos;),$locationSuffix),&apos;]:  &apos;),$cobieRowNameNoPrefix)
else
concat(concat(concat(sps:singularizeSheetName($locationPrefix),&apos;[&apos;),$locationSuffix),&apos;]&apos;)
else 
concat(sps:singularizeSheetName($locationPrefix),&apos;[*]&apos;)"/>
						<xsl:variable name="lastRuleFired" as="xs:string" select="preceding-sibling::svrl:fired-rule[1]/@id"/>
						<altova:level>
							<altova:marker altova:name="Level2Section">
								<span>
									<xsl:text>&#160;</xsl:text>
								</span>
								<altova:bookmark>
									<xsl:attribute name="name">
										<xsl:value-of select="*:text/*:location"/>
									</xsl:attribute>
									<h4>
										<span>
											<altova:num-lvl altova:format="1.1.1"/>
										</span>
										<span>
											<xsl:text>&#160;</xsl:text>
										</span>
										<xsl:for-each select="$tableHeadingText">
											<xsl:value-of select="."/>
										</xsl:for-each>
										<span>
											<xsl:text>&#160;</xsl:text>
										</span>
									</h4>
								</altova:bookmark>
							</altova:marker>
							<br/>
							<xsl:if test="count(current-group()[not(sps:isAssertWarning(@id))])&gt;0">
								<table border="1">
									<xsl:variable name="altova:CurrContextGrid_3" select="."/>
									<xsl:variable name="altova:ColumnData"/>
									<thead>
										<tr>
											<th colspan="2">
												<span>
													<xsl:text>Errors</xsl:text>
												</span>
											</th>
										</tr>
										<tr>
											<th>
												<span>
													<xsl:text>Error ID</xsl:text>
												</span>
											</th>
											<th>
												<span>
													<xsl:text>Error Message</xsl:text>
												</span>
											</th>
										</tr>
									</thead>
									<tbody>
										<xsl:for-each-group group-adjacent="@id" select="current-group()[not(sps:isAssertWarning(@id))]">
											<xsl:for-each select="current-group()">
												<tr>
													<td>
														<altova:hyperlink>
															<xsl:choose>
																<xsl:when test="not(string(concat(&apos;#&apos;,encode-for-uri(@id))))">
																	<xsl:attribute name="href">
																		<xsl:text>#</xsl:text>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="substring(string(concat(&apos;#&apos;,encode-for-uri(@id))), 1, 1) = '#'">
																	<xsl:attribute name="href">
																		<xsl:value-of select="concat(&apos;#&apos;,encode-for-uri(@id))"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="href">
																		<xsl:if test="substring(string(concat(&apos;#&apos;,encode-for-uri(@id))), 2, 1) = ':'">
																			<xsl:text>file:///</xsl:text>
																		</xsl:if>
																		<xsl:value-of select="translate(string(concat(&apos;#&apos;,encode-for-uri(@id))), '&#x5c;', '/')"/>
																	</xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
															<xsl:for-each select="@id">
																<span>
																	<xsl:value-of select="string(.)"/>
																</span>
															</xsl:for-each>
														</altova:hyperlink>
													</td>
													<td>
														<xsl:for-each select="svrl:text">
															<xsl:for-each select="text()[1]">
																<xsl:choose>
																	<xsl:when test=". instance of element() or . instance of document-node()">
																		<xsl:apply-templates/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:value-of select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</xsl:for-each>
													</td>
												</tr>
											</xsl:for-each>
										</xsl:for-each-group>
									</tbody>
								</table>
							</xsl:if>
							<br/>
							<br/>
							<xsl:if test="count(current-group()[sps:isAssertWarning(@id)])&gt;0">
								<table border="1">
									<xsl:variable name="altova:CurrContextGrid_4" select="."/>
									<xsl:variable name="altova:ColumnData"/>
									<thead>
										<tr>
											<th colspan="2">
												<span>
													<xsl:text>Warnings</xsl:text>
												</span>
											</th>
										</tr>
										<tr>
											<th>
												<span>
													<xsl:text>Warning ID</xsl:text>
												</span>
											</th>
											<th>
												<span>
													<xsl:text>Warning Message</xsl:text>
												</span>
											</th>
										</tr>
									</thead>
									<tbody>
										<xsl:for-each-group group-adjacent="@id" select="current-group()[sps:isAssertWarning(@id)]">
											<xsl:for-each select="current-group()">
												<tr>
													<td>
														<altova:hyperlink>
															<xsl:choose>
																<xsl:when test="not(string(concat(&apos;#&apos;,encode-for-uri(@id))))">
																	<xsl:attribute name="href">
																		<xsl:text>#</xsl:text>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="substring(string(concat(&apos;#&apos;,encode-for-uri(@id))), 1, 1) = '#'">
																	<xsl:attribute name="href">
																		<xsl:value-of select="concat(&apos;#&apos;,encode-for-uri(@id))"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="href">
																		<xsl:if test="substring(string(concat(&apos;#&apos;,encode-for-uri(@id))), 2, 1) = ':'">
																			<xsl:text>file:///</xsl:text>
																		</xsl:if>
																		<xsl:value-of select="translate(string(concat(&apos;#&apos;,encode-for-uri(@id))), '&#x5c;', '/')"/>
																	</xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
															<xsl:for-each select="@id">
																<span>
																	<xsl:value-of select="string(.)"/>
																</span>
															</xsl:for-each>
														</altova:hyperlink>
													</td>
													<td>
														<xsl:for-each select="svrl:text">
															<xsl:for-each select="text()[1]">
																<xsl:choose>
																	<xsl:when test=". instance of element() or . instance of document-node()">
																		<xsl:apply-templates/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:value-of select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:for-each>
														</xsl:for-each>
													</td>
												</tr>
											</xsl:for-each>
										</xsl:for-each-group>
									</tbody>
								</table>
							</xsl:if>
						</altova:level>
						<br/>
						<span>
							<xsl:text>&#160;</xsl:text>
						</span>
						<div style="text-align:left; ">
							<altova:hyperlink>
								<xsl:choose>
									<xsl:when test="not(string(&apos;#TOC&apos;))">
										<xsl:attribute name="href">
											<xsl:text>#</xsl:text>
										</xsl:attribute>
									</xsl:when>
									<xsl:when test="substring(string(&apos;#TOC&apos;), 1, 1) = '#'">
										<xsl:attribute name="href">
											<xsl:value-of select="&apos;#TOC&apos;"/>
										</xsl:attribute>
									</xsl:when>
									<xsl:otherwise>
										<xsl:attribute name="href">
											<xsl:if test="substring(string(&apos;#TOC&apos;), 2, 1) = ':'">
												<xsl:text>file:///</xsl:text>
											</xsl:if>
											<xsl:value-of select="translate(string(&apos;#TOC&apos;), '&#x5c;', '/')"/>
										</xsl:attribute>
									</xsl:otherwise>
								</xsl:choose>
								<span style="padding-left:25px; ">
									<xsl:text>Table of Contents</xsl:text>
								</span>
							</altova:hyperlink>
						</div>
					</xsl:for-each-group>
				</altova:level>
				<span>
					<xsl:text>&#160; </xsl:text>
				</span>
				<hr/>
			</xsl:for-each-group>
		</altova:level>
	</xsl:template>
	<xsl:template match="/">
		<xsl:variable name="altova:Design">
			<xsl:for-each select="$altova:DesignAfterStep1">
				<xsl:apply-templates mode="altova:step2"/>
			</xsl:for-each>
		</xsl:variable>
		<xsl:apply-templates select="$altova:Design" mode="altova:WriteResultDoc"/>
		<xsl:if test="$altova:bGeneratingFromPxf">
			<xsl:for-each select="distinct-values(for $i in $altova:DesignAfterStep1//img[not(@altova:ImageDataBase64)]/@src return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://'))">
					<xsl:if test="unparsed-text-available(., 'binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="base64tobinary">
							<xsl:value-of select="unparsed-text(., 'binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="distinct-values(for $i in $altova:toc-xslt-tree//img[not(@altova:ImageDataBase64)]/@src return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://'))">
					<xsl:if test="unparsed-text-available(., 'binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="base64tobinary">
							<xsl:value-of select="unparsed-text(., 'binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="distinct-values(for $i in $altova:CssImages/altova:CssImage/@altova:sUrl return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://'))">
					<xsl:if test="unparsed-text-available(., 'binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="base64tobinary">
							<xsl:value-of select="unparsed-text(., 'binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:step2">
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="xhtml:table" mode="altova:step2">
		<xsl:variable name="altova:table">
			<xsl:copy copy-namespaces="no">
				<xsl:apply-templates select="@* | node()" mode="#current"/>
			</xsl:copy>
		</xsl:variable>
		<xsl:apply-templates select="$altova:table" mode="altova:generate-table"/>
	</xsl:template>
	<xsl:variable name="altova:toc-xslt-tree1">
		<xsl:for-each select="$altova:DesignAfterStep1">
			<xsl:apply-templates mode="altova:generate-toc-xslt-tree"/>
		</xsl:for-each>
	</xsl:variable>
	<xsl:template match="altova:level" mode="altova:generate-toc-xslt-tree">
		<altova:level altova:design-id="{generate-id()}">
			<xsl:apply-templates mode="#current"/>
		</altova:level>
	</xsl:template>
	<xsl:template match="altova:marker" mode="altova:generate-toc-xslt-tree">
		<altova:marker altova:design-id="{generate-id()}" altova:name="{@altova:name}">
			<xsl:apply-templates mode="#current"/>
		</altova:marker>
	</xsl:template>
	<xsl:template match="@* | text()" mode="altova:generate-toc-xslt-tree"/>
	<xsl:template match="altova:UnescapedText" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="text()" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="altova:num-lvl" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy>
			<xsl:copy-of select="@*"/>
			<xsl:attribute name="altova:level-design-id" select="$altova:level-design-id"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:num-seq" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy>
			<xsl:copy-of select="@*"/>
			<xsl:attribute name="altova:marker-design-id" select="generate-id( ancestor::altova:marker[1] )"/>
		</xsl:copy>
	</xsl:template>
	<xsl:variable name="altova:toc-xslt-tree" select="$altova:toc-xslt-tree1"/>
	<xsl:key name="altova:bookmark-key" match="altova:bookmark" use="@name"/>
	<xsl:key name="altova:toc-xslt-tree-key" match="altova:level | altova:toc | altova:ref | altova:marker" use="@altova:design-id"/>
	<xsl:template match="altova:main-document" mode="altova:step2">
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:level" mode="altova:step2">
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:bookmark | altova:hyperlink" mode="altova:step2">
		<a>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</a>
	</xsl:template>
	<xsl:template match="altova:hyperlink/@href[starts-with(.,'#')]" mode="altova:step2">
		<xsl:variable name="altova:bookmark-name" select="substring(.,2)"/>
		<xsl:attribute name="href">
			<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
			<xsl:variable name="altova:target-document" select="key('altova:bookmark-key',$altova:bookmark-name,$altova:DesignAfterStep1)[1]/ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
			<xsl:value-of select="concat(altova:calc-relative-path($altova:source-document/@url,$altova:target-document/@url),.)"/>
		</xsl:attribute>
	</xsl:template>
	<xsl:template match="altova:toc | altova:ref" mode="altova:step2">
		<xsl:apply-templates select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', generate-id( current() ) )/node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:marker" mode="altova:step2">
		<a name="{generate-id()}"/>
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:num-lvl" mode="altova:step2">
		<xsl:variable name="altova:format" select="@altova:format"/>
		<xsl:variable name="altova:omit-levels" select="@altova:omit-levels"/>
		<xsl:variable name="altova:level-design-id">
			<xsl:choose>
				<xsl:when test="@altova:level-design-id">
					<xsl:value-of select="@altova:level-design-id"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="generate-id( ancestor::altova:level[1] )"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:for-each select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', $altova:level-design-id )">
			<xsl:choose>
				<xsl:when test="$altova:omit-levels">
					<xsl:number level="multiple" count="altova:level[ count( ancestor::altova:level ) >= $altova:omit-levels ]" format="{$altova:format}"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:number level="multiple" count="altova:level" format="{$altova:format}"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="altova:num-seq" mode="altova:step2">
		<xsl:variable name="altova:format" select="@altova:format"/>
		<xsl:variable name="altova:marker-design-id">
			<xsl:choose>
				<xsl:when test="@altova:marker-design-id">
					<xsl:value-of select="@altova:marker-design-id"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="generate-id( ancestor::altova:marker[1] )"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:for-each select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', $altova:marker-design-id )">
			<xsl:variable name="altova:name" select="@altova:name"/>
			<xsl:number level="any" count="altova:marker[ @altova:name = $altova:name ]" format="{$altova:format}"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:function name="altova:calc-relative-path" as="xs:string">
		<xsl:param name="altova:source-path"/>
		<xsl:param name="altova:target-path"/>
		<xsl:choose>
			<xsl:when test="$altova:source-path = $altova:target-path">
				<xsl:sequence select="''"/>
			</xsl:when>
			<xsl:when test="starts-with($altova:target-path,'http:') or starts-with($altova:target-path,'ftp:') or starts-with($altova:target-path,'file:')">
				<xsl:sequence select="$altova:target-path"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:source-parts" select="tokenize($altova:source-path,'[/\\]')"/>
				<xsl:variable name="altova:target-parts" select="tokenize($altova:target-path,'[/\\]')"/>
				<xsl:variable name="altova:common-part-count" select="sum(for $i in (1 to count($altova:source-parts) - 1) return if( subsequence($altova:source-parts,1,$i) = subsequence($altova:target-parts,1,$i) ) then 1 else 0)"/>
				<xsl:sequence select="string-join((for $i in ($altova:common-part-count + 1 to count($altova:source-parts) - 1) return '..',for $i in ($altova:common-part-count + 1 to count($altova:target-parts)) return $altova:target-parts[$i]),'/')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:map-preview-filepath" as="xs:string">
		<xsl:param name="filepath"/>
		<xsl:sequence select="altovaext:create-temp-file-mapping($filepath)" use-when="function-available('altovaext:create-temp-file-mapping',1)"/>
		<xsl:sequence select="$filepath" use-when="not(function-available('altovaext:create-temp-file-mapping',1))"/>
	</xsl:function>
	<xsl:function name="altova:is-cell-empty" as="xs:boolean">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="altova:is-node-empty( $altova:cell )"/>
	</xsl:function>
	<xsl:function name="altova:is-node-empty" as="xs:boolean">
		<xsl:param name="altova:node" as="element()"/>
		<xsl:sequence select="every $altova:child in $altova:node/child::node() satisfies ( ( boolean( $altova:child/self::text() ) and string-length( $altova:child ) = 0 ) or ( ( boolean( $altova:child/self::xhtml:div ) or boolean( $altova:child/self::xhtml:span ) or boolean( $altova:child/self::xhtml:a ) ) and altova:is-node-empty( $altova:child ) ) )"/>
	</xsl:function>
	<xsl:function name="altova:col-span" as="xs:integer">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="if ( exists( $altova:cell/@colspan ) ) then xs:integer( $altova:cell/@colspan ) else 1"/>
	</xsl:function>
	<xsl:template match="@* | node()" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current">
				<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="xhtml:tbody" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:choose>
			<xsl:when test="empty(xhtml:tr)">
				<xsl:copy>
					<tr>
						<td/>
					</tr>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current">
						<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
					</xsl:apply-templates>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="xhtml:th | xhtml:td" mode="altova:generate-table">
		<xsl:choose>
			<xsl:when test="altova:is-cell-empty( . )">
				<xsl:copy>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:text>&#160;</xsl:text>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:WriteResultDoc">
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:UnescapedText" mode="altova:WriteResultDoc">
		<xsl:value-of select="." disable-output-escaping="yes"/>
	</xsl:template>
	<xsl:function name="altova:GetChartYValuesForSingleSeries">
		<xsl:param name="seqCategoryLeafPos" as="node()*"/>
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:for-each select="$seqCategoryLeafPos">
			<xsl:element name="altova:Value">
				<xsl:value-of select="altova:GetChartYValueForSingleSeriesPos($nodeSeriesLeafPos, ., $bValuesInCategory)"/>
			</xsl:element>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="altova:GetChartYValueForSingleSeriesPos">
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="nodeCategoryLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:variable name="altova:seqCategoryContextIds" select="$nodeCategoryLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:seqSeriesContextIds" select="$nodeSeriesLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:sCommonContextId" select="for $i in $altova:seqCategoryContextIds return if (some $j in $altova:seqSeriesContextIds satisfies $i eq $j) then $i else ()" as="xs:string*"/>
		<xsl:choose>
			<xsl:when test="count($altova:sCommonContextId) gt 1">
				<xsl:message select="concat('Found several values instead of a single one (contexts: ', string-join($altova:sCommonContextId, ', '), ').')" terminate="yes"/>
			</xsl:when>
			<xsl:when test="count($altova:sCommonContextId) lt 1">
				<xsl:message select="concat('XBRL Chart: Info: No value found for position labeled &quot;', $nodeCategoryLeafPos/@altova:sLabel, '&quot;')" terminate="no"/>
				<xsl:sequence select="'altova:no-value'"/>
			</xsl:when>
			<xsl:when test="$bValuesInCategory">
				<xsl:sequence select="xs:string($nodeCategoryLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="xs:string($nodeSeriesLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartLabelForPos" as="xs:string">
		<xsl:param name="nodeParam" as="node()"/>
		<xsl:value-of select="string-join($nodeParam/ancestor-or-self::altova:Pos/@altova:sLabel, ' ')"/>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-pixel" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="substring-before($normLength, 'px')"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * $altova:nPxPerIn"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * $altova:nPxPerIn div 2.54"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'mm')) * $altova:nPxPerIn div 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * $altova:nPxPerIn div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * $altova:nPxPerIn div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$normLength"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-mm" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'px')) div $altova:nPxPerIn * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * 10"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="substring-before($normLength, 'mm') "/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * 25.4 div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * 25.4 div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($normLength) div $altova:nPxPerIn * 25.4"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="sps:singularizeSheetName" as="xs:string">
		<xsl:param name="sheetNameString" as="xs:string"/>
		<xsl:sequence select="replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace($sheetNameString,&apos;Facilities&apos;,&apos;Facility&apos;),&apos;Contacts&apos;,&apos;Contact&apos;),&apos;Floors&apos;,&apos;Floor&apos;),&apos;Spaces&apos;,&apos;Space&apos;),&apos;Zones&apos;,&apos;Zone&apos;),&apos;Types&apos;,&apos;Type&apos;),&apos;Components&apos;,&apos;Component&apos;),&apos;Attributes&apos;,&apos;Attribute&apos;),&apos;Systems&apos;,&apos;System&apos;),&apos;Assemblies&apos;,&apos;Assembly&apos;),&apos;Documents&apos;,&apos;Document&apos;),&apos;Connections&apos;,&apos;Connection&apos;),&apos;Spares&apos;,&apos;Spare&apos;),&apos;Jobs&apos;,&apos;Job&apos;),&apos;Resources&apos;,&apos;Resource&apos;),&apos;Coordinates&apos;,&apos;Coordinate&apos;),&apos;Issues&apos;,&apos;Issue&apos;),&apos;Impacts&apos;,&apos;Impact&apos;)"/>
	</xsl:function>
	<xsl:function name="sps:isPluralSheetName" as="xs:boolean">
		<xsl:param name="sheetName" as="xs:string"/>
		<xsl:sequence select="if ( $sheetName=&apos;Contacts&apos;) 
then true()
else
if($sheetName=&apos;Facilities&apos;)
then true()
else
if ($sheetName=&apos;Floors&apos;)
then true()
else
if($sheetName=&apos;Spaces&apos;)
then true()
else
if($sheetName=&apos;Zones&apos;)
then true()
else
if($sheetName=&apos;Types&apos;)
then true()
else
if($sheetName=&apos;Components&apos;)
then true()
else
if($sheetName=&apos;Systems&apos;)
then true()
else
if($sheetName=&apos;Assemblies&apos;)
then true()
else if($sheetName=&apos;Documents&apos;)
then true()
else
if($sheetName=&apos;Resources&apos;)
then true()
else
if($sheetName=&apos;Jobs&apos;)
then true()
else
if($sheetName=&apos;Impacts&apos;)
then true()
else
if($sheetName=&apos;Issues&apos;)
then true()
else
if ($sheetName=&apos;Connections&apos;)
then true()
else
if ($sheetName=&apos;Coordinates&apos;)
then true()
else
if ($sheetName=&apos;Spares&apos;)
then true()
else
if($sheetName=&apos;Attributes&apos;)
then true()
else
false()"/>
	</xsl:function>
	<xsl:function name="sps:isAssertWarning" as="xs:boolean">
		<xsl:param name="id" as="xs:string"/>
		<xsl:sequence select="ends-with($id,&apos;Warning&apos;)"/>
	</xsl:function>
	<xsl:function name="sps:COBieLocationHeading" as="xs:string">
		<xsl:param name="cobiePathString"/>
		<xsl:sequence select="replace(replace($cobiePathString,&apos;\[&apos;,&apos; &apos;),&apos;\]&apos;,&apos;&apos;)"/>
	</xsl:function>
</xsl:stylesheet>
